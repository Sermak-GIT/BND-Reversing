Bei Level 3 handelt es sich um eine native 32-bit Dll, vermutlich in C/C++ geschrieben.Beim Betrachten der DllMain (sub_10002CB0) erkennt man, dass diese lediglich true zurückgibt. Daraus kann man ableiten, dass die Dll andersweitig in der Lage sein muss, Code zu executen. Ein Blick in den Exporttable klärt auf: isDebuggerPresent(x,x). Aha, netter Joke. Eine exportierte Funktion, welche zwei Parameter besitzt, augenscheinlich zwei wchar Pointer.Der erste Parameter steht für eine Partition, der zweite für den Namen einer Outputfile. Ich werde nun einfach mal den teilweise analysierten decompiled Code der isDebuggerPresent Funktion zeigen, somit erspare ich mir eine Menge Erklärungen:____________________________________________________________________________________________________________________________char __stdcall isDebuggerPresent(LPCWSTR directory, LPCWSTR file_name){  char v2; // bh@0  char *v3; // eax@4  int v4; // ecx@4  void *v5; // ST18_4@8  void *v6; // eax@8  _DWORD *directoy_path; // eax@8  char v8; // bl@8  char *v9; // eax@14  int string_fertig; // eax@16  char result; // al@20  void *v12; // [sp+8h] [bp-48h]@8  int v13; // [sp+18h] [bp-38h]@10  unsigned int v14; // [sp+1Ch] [bp-34h]@8  void *a1a; // [sp+20h] [bp-30h]@4  int v16; // [sp+30h] [bp-20h]@12  unsigned int v17; // [sp+34h] [bp-1Ch]@6  void *v18; // [sp+38h] [bp-18h]@8  unsigned int v19; // [sp+4Ch] [bp-4h]@12  if ( wcslen(directory) != 2  // it has to be a valid dir, 2 chars  || directory[1] != ':'  // :  || (created_file = CreateFileW(file_name, 0x40000000u, 1u, 0, 2u, 0x80u, 0), created_file == (HANDLE)-1) )// create that file  {  result = 0;  }  else  {  v3 = string_decryption(&a1a, (int)&dword_100177B0);// resolves "amigurumi"  if ( *((_DWORD *)v3 + 5) >= (unsigned int)'\b' )  v3 = *(char **)v3;  rc4_init(v4, (wchar_t *)v3);  if ( v17 >= 8 )  j__free(a1a);  v5 = (void *)string_constructor((int)&v18, "\\");  v6 = (void *)string_constructor((int)&a1a, (void *)directory);  directoy_path = strcat(&v12, v6, v5);  v8 = recursive_dir_search(0, directoy_path, v2);  if ( v14 >= 8 )  j__free(v12);  v14 = 7;  v13 = 0;  LOWORD(v12) = 0;  if ( v17 >= 8 )  j__free(a1a);  v17 = 7;  v16 = 0;  LOWORD(a1a) = 0;  if ( v19 >= 8 )  j__free(v18);  v9 = string_decryption(&v12, (int)&dword_100177D0);// Fertig.  if ( *((_DWORD *)v9 + 5) >= 8u )  v9 = *(char **)v9;  string_fertig = string_constructor((int)&a1a, v9);  output_to_file(string_fertig, 0, 0);  if ( v17 >= 8 )  j__free(a1a);  v17 = 7;  v16 = 0;  LOWORD(a1a) = 0;  if ( v14 >= 8 )  j__free(v12);  v14 = 7;  v13 = 0;  LOWORD(v12) = 0;  CloseHandle(created_file);  created_file = (HANDLE)-1;  result = v8;  }  return result;  ____________________________________________________________________________________________________________________________________________(Das j__free Zeug kann man ignorieren.)Checks wie diese in Zeile 22 und 23 (in Verbindung mit Zeile 38) zeigen eindeutig, warum es sich um eine Partition handeln muss.Kleine Anmerkung: Damit ich mir nicht die Mühe machen musste, die "string_decryption" Funktion nachzubauen, habe ich einfach mit Ollydbg einen Breakpoint auf jede Referenz gesetzt und die entschlüsselten Strings mitgeloggt. Das ersparte mir viel Zeit.Als nächstes gehe ich kurz auf die "rc4_init" (mehr oder weniger gängiger Name) Funktion ein:_________________________________________________________________________________________________________________________int __fastcall rc4_init(int unused, wchar_t *password){  unsigned int v3; // eax@1  int v4; // edx@3  int v5; // edi@3  unsigned int counter; // esi@3  char current_char; // al@4  unsigned int accessor; // edx@4  char saved_char; // cl@4  char v10; // al@4  int result; // eax@4  static_counter1 = 0;  static_counter2 = 0;  v3 = 0;  do  {  xor_array[v3] = v3;  ++v3;  }  while ( v3 < 256 );  // init all xor keys 0 - 0xFF  v4 = 0;  LOBYTE(v5) = 0;  counter = 0;  do  {  current_char = *((_BYTE *)password + v4);  accessor = v4 + 1;  saved_char = xor_array[counter];  v5 = (unsigned __int8)(saved_char + current_char + v5);  v10 = xor_array[v5];  xor_array[v5] = saved_char;  xor_array[counter] = v10;  result = -(accessor < 18);  ++counter;  v4 = result & accessor;  }  while ( counter < 0x100 );  return result;}______________________________________________________________________________________________________________________________Mit ein bisschen Erfahrung lässt sich erkennen, dass es sich hierbei um einen Teil der RC4 Encryption handelt. Sucht euch einfach mal öffentlichen Code dieser Verschlüsselung und ihr werdet schnell Ähnlichkeiten feststellen. "Amigurumi" dient hier also als Passwort (wird später abgefragt im Antwortbogen).Das eigentliche "Herz" des dritten Levels liegt aber in der "recursive_dir_search" Funktion. Diese ist _SEHR_ groß und ich werde nur grob auf einige Stellen genauer eingehen. Bevor man diese allerdings decompilen kann, muss man sich erst um einige "Junkbytes" kümmern. Die Entwickler dieses Levels haben vor legitime Instructions überflüssige Bytes gesetzt, welche allerdings nie executed werden. Da der Disassembler/Decompiler das allerdings nicht weiß, wird er an einigen Stellen zu falschen Ergebnissen gelangen. Man kann mit Ollydbg schnell herrausfinden, welche Bytes übersprungen werden und diese dann anschließend durch NOPs ersetzen. Hat man dies getan, sieht die Funktion in etwa so aus:____________________________________________________________________________________________________________________________________char __usercall recursive_dir_search@<al>(char a1@<dl>, void *directoy_path@<ecx>, char a3@<bh>){  signed __int16 found_haekelmuster_dir__; // bx@1  char *String_FindFirstFileW; // esi@1  char *String_Kernel32; // eax@1  HMODULE FindFirstFileW; // edi@1  char *String_FindNextFileW; // esi@5  char *String_Kernel32_; // eax@5  char *String_FindClose; // esi@9  char *String_Kernel32__; // eax@9  HMODULE FindClose; // esi@9  void *v12; // ecx@16  char *v13; // eax@16  void *v14; // esi@16  int first_file_name; // eax@16  int v16; // edi@18  char *v17; // eax@25  char found_haekelmuster_dir; // al@27  char *v19; // eax@31  char v20; // al@33  int length_of_dir_name; // ecx@38  void *v22; // eax@40  _DWORD *new_directory; // eax@40  char v24; // al@40  char result; // al@51  int v26; // ecx@53  char *v27; // eax@55  char v28; // al@57  signed int v29; // ebx@59  char *v30; // eax@61  char v31; // al@63  char *v32; // eax@67  char v33; // al@69  int v34; // ecx@69  char *v35; // eax@74  const unsigned __int16 *v36; // edx@74  unsigned int v37; // ecx@77  bool v38; // bl@79  BYTE *md5_result_; // ecx@82  unsigned int v40; // esi@82  BYTE *computed_hash_; // edx@82  bool v42; // cf@84  char *v43; // ecx@87  unsigned int v44; // esi@87  int *v45; // edx@87  char *v46; // ecx@91  unsigned int v47; // esi@91  int *v48; // edx@91  char *v49; // ecx@95  unsigned int v50; // esi@95  int *v51; // edx@95  char *v52; // ecx@99  unsigned int v53; // esi@99  int *v54; // edx@99  char *v55; // ecx@103  unsigned int v56; // esi@103  int *v57; // edx@103  char *v58; // ecx@107  unsigned int v59; // esi@107  int *v60; // edx@107  char *v61; // ecx@111  unsigned int v62; // esi@111  int *v63; // edx@111  char *v64; // ecx@115  unsigned int v65; // esi@115  int *v66; // edx@115  char *v67; // ecx@119  unsigned int v68; // esi@119  int *v69; // edx@119  bool v70; // zf@127  char *v71; // eax@129  const unsigned __int16 *v72; // edx@129  int v73; // ecx@132  int size_of_name; // eax@134  char v75; // [sp+0h] [bp-490h]@0  WIN32_FIND_DATA find_file_data; // [sp+10h] [bp-480h]@18  signed int v77; // [sp+260h] [bp-230h]@82  unsigned int v78; // [sp+264h] [bp-22Ch]@82  unsigned int v79; // [sp+268h] [bp-228h]@82  signed int v80; // [sp+26Ch] [bp-224h]@82  int v81; // [sp+270h] [bp-220h]@82  int v82; // [sp+274h] [bp-21Ch]@82  void *v83; // [sp+2B8h] [bp-1D8h]@5  int v84; // [sp+2C8h] [bp-1C8h]@7  unsigned int v85; // [sp+2CCh] [bp-1C4h]@5  void *v86; // [sp+2D0h] [bp-1C0h]@21  int v87; // [sp+2E0h] [bp-1B0h]@22  unsigned int v88; // [sp+2E4h] [bp-1ACh]@20  void *v89; // [sp+2E8h] [bp-1A8h]@9  int v90; // [sp+2F8h] [bp-198h]@11  unsigned int v91; // [sp+2FCh] [bp-194h]@9  void *v92; // [sp+300h] [bp-190h]@9  int v93; // [sp+310h] [bp-180h]@13  unsigned int v94; // [sp+314h] [bp-17Ch]@11  void *v95; // [sp+318h] [bp-178h]@5  int v96; // [sp+328h] [bp-168h]@9  unsigned int v97; // [sp+32Ch] [bp-164h]@7  void *v98; // [sp+330h] [bp-160h]@16  int v99; // [sp+340h] [bp-150h]@20  unsigned int v100; // [sp+344h] [bp-14Ch]@18  void *v101; // [sp+348h] [bp-148h]@40  int v102; // [sp+358h] [bp-138h]@42  unsigned int v103; // [sp+35Ch] [bp-134h]@40  void (__stdcall *FindClose_)(int); // [sp+360h] [bp-130h]@9  void *v105; // [sp+364h] [bp-12Ch]@52  unsigned int v106; // [sp+374h] [bp-11Ch]@52  unsigned int v107; // [sp+378h] [bp-118h]@52  void *a1a; // [sp+37Ch] [bp-114h]@1  int v109; // [sp+38Ch] [bp-104h]@3  unsigned int v110; // [sp+390h] [bp-100h]@1  char md5_result; // [sp+394h] [bp-FCh]@82  int v112; // [sp+3A4h] [bp-ECh]@73  HMODULE FindNextFileW; // [sp+3A8h] [bp-E8h]@5  unsigned int new_hash9; // [sp+3ACh] [bp-E4h]@74  int v115; // [sp+3B0h] [bp-E0h]@74  int v116; // [sp+3B4h] [bp-DCh]@74  unsigned int v117; // [sp+3B8h] [bp-D8h]@74  unsigned int new_hash3; // [sp+3BCh] [bp-D4h]@74  int v119; // [sp+3C0h] [bp-D0h]@74  int v120; // [sp+3C4h] [bp-CCh]@74  int v121; // [sp+3C8h] [bp-C8h]@74  unsigned int new_hash7; // [sp+3CCh] [bp-C4h]@74  unsigned int v123; // [sp+3D0h] [bp-C0h]@74  int v124; // [sp+3D4h] [bp-BCh]@74  unsigned int v125; // [sp+3D8h] [bp-B8h]@74  int new_hash4; // [sp+3DCh] [bp-B4h]@74  unsigned int v127; // [sp+3E0h] [bp-B0h]@74  unsigned int v128; // [sp+3E4h] [bp-ACh]@74  int v129; // [sp+3E8h] [bp-A8h]@74  int new_hash2; // [sp+3ECh] [bp-A4h]@74  unsigned int v131; // [sp+3F0h] [bp-A0h]@74  int v132; // [sp+3F4h] [bp-9Ch]@74  int v133; // [sp+3F8h] [bp-98h]@74  int computed_hash; // [sp+3FCh] [bp-94h]@74  int v135; // [sp+400h] [bp-90h]@74  int v136; // [sp+404h] [bp-8Ch]@74  unsigned int v137; // [sp+408h] [bp-88h]@74  int new_hash5; // [sp+40Ch] [bp-84h]@74  unsigned int v139; // [sp+410h] [bp-80h]@74  int v140; // [sp+414h] [bp-7Ch]@74  unsigned int v141; // [sp+418h] [bp-78h]@74  unsigned int new_hash; // [sp+41Ch] [bp-74h]@74  int v143; // [sp+420h] [bp-70h]@74  unsigned int v144; // [sp+424h] [bp-6Ch]@74  int v145; // [sp+428h] [bp-68h]@74  unsigned int new_hash6; // [sp+42Ch] [bp-64h]@74  int v147; // [sp+430h] [bp-60h]@74  int v148; // [sp+434h] [bp-5Ch]@74  unsigned int v149; // [sp+438h] [bp-58h]@74  unsigned int new_hash8; // [sp+43Ch] [bp-54h]@74  int v151; // [sp+440h] [bp-50h]@74  unsigned int v152; // [sp+444h] [bp-4Ch]@74  unsigned int v153; // [sp+448h] [bp-48h]@74  void *gefunden_format; // [sp+44Ch] [bp-44h]@1  int v155; // [sp+45Ch] [bp-34h]@5  unsigned int v156; // [sp+460h] [bp-30h]@3  void *v157; // [sp+464h] [bp-2Ch]@25  unsigned int v158; // [sp+474h] [bp-1Ch]@44  unsigned int v159; // [sp+478h] [bp-18h]@27  void *directoy_path_; // [sp+47Ch] [bp-14h]@1  char v161; // [sp+481h] [bp-Fh]@16  char v162; // [sp+482h] [bp-Eh]@1  char found_valid_file; // [sp+483h] [bp-Dh]@27  int v164; // [sp+48Ch] [bp-4h]@1  LOBYTE(found_haekelmuster_dir__) = a1;  directoy_path_ = directoy_path;  v162 = a1;  String_FindFirstFileW = string_decryption(&gefunden_format, (int)&Unk_FindFirstFileW);// findfirstfilew  v164 = 0;  String_Kernel32 = string_decryption(&a1a, (int)&Unk_Kernel32);// kErnEl32  FindFirstFileW = getprocaddress_((LPCWSTR)String_Kernel32, (LPCWSTR)String_FindFirstFileW);  if ( v110 >= 8 )  j__free(a1a);  v164 = -1;  v110 = 7;  v109 = 0;  LOWORD(a1a) = 0;  if ( v156 >= 8 )  j__free(gefunden_format);  v156 = 7;  v155 = 0;  LOWORD(gefunden_format) = 0;  String_FindNextFileW = string_decryption(&v95, (int)&Unk_FindNextFileW);// findnextfilew  v164 = 1;  String_Kernel32_ = string_decryption(&v83, (int)&Unk_Kernel32_);// KeRnEL32  FindNextFileW = getprocaddress_((LPCWSTR)String_Kernel32_, (LPCWSTR)String_FindNextFileW);  if ( v85 >= 8 )  j__free(v83);  v164 = -1;  v85 = 7;  v84 = 0;  LOWORD(v83) = 0;  if ( v97 >= 8 )  j__free(v95);  v97 = 7;  v96 = 0;  LOWORD(v95) = 0;  String_FindClose = string_decryption(&v92, (int)&Unk_FindClose);// findclose  v164 = 2;  String_Kernel32__ = string_decryption(&v89, (int)&Unk_Kernel32__);// keRNEl32  FindClose = getprocaddress_((LPCWSTR)String_Kernel32__, (LPCWSTR)String_FindClose);  FindClose_ = (void (__stdcall *)(int))FindClose;  if ( v91 >= 8 )  j__free(v89);  v164 = -1;  v91 = 7;  v90 = 0;  LOWORD(v89) = 0;  if ( v94 >= 8 )  j__free(v92);  v94 = 7;  v93 = 0;  LOWORD(v92) = 0;  if ( FindFirstFileW && FindNextFileW && FindClose )  {  useless_obfuscation();  v161 = a3;  v13 = string_decryption(v12, (int)&unk_10017660);// UNICODE "\*.*" get any dir  v14 = directoy_path_;  v164 = 3;  first_file_name = strcpy((int)&v98, directoy_path_, v13);  LOBYTE(v164) = 4;  if ( *(_DWORD *)(first_file_name + 20) >= 8u )  first_file_name = *(_DWORD *)first_file_name;  v16 = ((int (__stdcall *)(int, WIN32_FIND_DATA *))FindFirstFileW)(first_file_name, &find_file_data);  if ( v100 >= 8 )  j__free(v98);  v164 = -1;  v100 = 7;  v99 = 0;  LOWORD(v98) = 0;  if ( v88 >= 8 )  j__free(v86);  v88 = 7;  v87 = 0;  LOWORD(v86) = 0;  if ( v16 != -1 )  {  do  {  if ( find_file_data.dwFileAttributes & 0x10 )// did we find a directory (FILE_ATTRIBUTE_DIRECTORY = 0x10)  {  if ( *(_WORD *)&find_file_data.cFileName[0] != '.' )  {  v17 = string_decryption(&v157, (int)&Unk_Haekelmuster1);// Häkelmuster with ä!!!!!!  if ( *((_DWORD *)v17 + 5) >= 8u )  v17 = *(char **)v17;  found_haekelmuster_dir = _wcsicmp((const wchar_t *)find_file_data.cFileName, (const wchar_t *)v17) == 0;  found_valid_file = found_haekelmuster_dir;  if ( v159 >= 8 )  {  j__free(v157);  found_haekelmuster_dir = found_valid_file;  }  if ( found_haekelmuster_dir )  LOBYTE(found_haekelmuster_dir__) = 1;  v19 = string_decryption(&v157, (int)&Unk_Haekelmuster2);// Haekelmuster without ä!!!!  if ( *((_DWORD *)v19 + 5) >= 8u )  v19 = *(char **)v19;  v20 = _wcsicmp((const wchar_t *)find_file_data.cFileName, (const wchar_t *)v19) == 0;  found_valid_file = v20;  if ( v159 >= 8 )  {  j__free(v157);  v20 = found_valid_file;  }  found_haekelmuster_dir__ = (unsigned __int8)found_haekelmuster_dir__;  v110 = 7;  if ( v20 )  found_haekelmuster_dir__ = 1;  v109 = 0;  LOWORD(a1a) = 0;  if ( *(_WORD *)&find_file_data.cFileName[0] )  length_of_dir_name = wcslen((const unsigned __int16 *)find_file_data.cFileName);  else  length_of_dir_name = 0;  memcpy((int)&a1a, find_file_data.cFileName, length_of_dir_name);  v164 = 5;  v156 = 7;  v155 = 0;  LOWORD(gefunden_format) = 0;  memcpy((int)&gefunden_format, "\\", 1);  LOBYTE(v164) = 6;  v22 = (void *)strcpy((int)&v157, v14, &gefunden_format);  LOBYTE(v164) = 7;  new_directory = strcat(&v101, v22, &a1a);  LOBYTE(v164) = 8;  v24 = recursive_dir_search(found_haekelmuster_dir__, new_directory, SHIBYTE(found_haekelmuster_dir__));  v161 |= v24;  if ( v103 >= 8 )  j__free(v101);  v103 = 7;  v102 = 0;  LOWORD(v101) = 0;  if ( v159 >= 8 )  j__free(v157);  v159 = 7;  v158 = 0;  LOWORD(v157) = 0;  if ( v156 >= 8 )  j__free(gefunden_format);  v164 = -1;  v156 = 7;  v155 = 0;  LOWORD(gefunden_format) = 0;  if ( v110 >= 8 )  j__free(a1a);  LOBYTE(found_haekelmuster_dir__) = v162;  }  }  else  {  v107 = 7;  v106 = 0;  LOWORD(v105) = 0;  if ( *(_WORD *)&find_file_data.cFileName[0] )  v26 = wcslen((const unsigned __int16 *)find_file_data.cFileName);  else  v26 = 0;  memcpy((int)&v105, find_file_data.cFileName, v26);  v164 = 9;  v27 = string_decryption(&v157, (int)&unk_100176D0);// Büschelmaschen.jpg  if ( *((_DWORD *)v27 + 5) >= 8u )  v27 = *(char **)v27;  v28 = _wcsicmp((const wchar_t *)find_file_data.cFileName, (const wchar_t *)v27) == 0;  found_valid_file = v28;  if ( v159 >= 8 )  {  j__free(v157);  v28 = found_valid_file;  }  LOBYTE(v29) = 0;  if ( v28 )  LOBYTE(v29) = 1;  v30 = string_decryption(&v157, (int)&unk_10017700);// Kettmaschen.jpg  if ( *((_DWORD *)v30 + 5) >= 8u )  v30 = *(char **)v30;  v31 = _wcsicmp((const wchar_t *)find_file_data.cFileName, (const wchar_t *)v30) == 0;  found_valid_file = v31;  if ( v159 >= 8 )  {  j__free(v157);  v31 = found_valid_file;  }  if ( v31 )  LOBYTE(v29) = 1;  v32 = string_decryption(&v157, (int)&unk_10017730);// Topflappen.jpg  if ( *((_DWORD *)v32 + 5) >= 8u )  v32 = *(char **)v32;  v33 = _wcsicmp((const wchar_t *)find_file_data.cFileName, (const wchar_t *)v32) == 0;  found_valid_file = v33;  if ( v159 >= 8 )  {  j__free(v157);  v33 = found_valid_file;  }  v29 = (unsigned __int8)v29;  if ( v33 )  v29 = 1;  v112 = v29;  if ( v106 >= 8 )  {  computed_hash = 0x78440D12;  v135 = 0x30345F1E;  v136 = 0x6887213C;  v137 = 0xE12465C1;  new_hash = 0xC6DD61BE;  v143 = 0x741077EA;  v144 = 0x80F53A6B;  v145 = 0x47C05A2F;  new_hash2 = 0x78A75BF0;  v131 = 0xB14F95CD;  v132 = 0x17D17AC2;  v133 = 0x75B06B0E;  new_hash3 = 0xFE64365C;  v119 = 0x576ACC51;  v120 = 0x70A22858;  v121 = 0x43D40F37;  new_hash4 = 0x7F9FB97E;  v127 = 0x85707DDA;  v128 = 0xA2BDE1A1;  v129 = 0x11A34AB0;  new_hash5 = 0x5EC20AEA;  v139 = 0xDF531C51;  v140 = 0x1BD49218;  v141 = 0x8202B9C8;  new_hash6 = 0x87FDCF71;  v147 = 0x4B82FD9C;  v148 = 0x137A8BAA;  v149 = 0xD55096A1;  new_hash7 = 0xDA70241D;  v123 = 0x90FC9224;  v124 = 0xD3B15F;  v125 = 0xDE4A49BA;  new_hash8 = 0xA81C251F;  v151 = 0x399C436A;  v152 = 0xF85D4AA0;  v153 = 0xE2BB7CA1;  new_hash9 = 0x8045AAC5;  v115 = 0x6BF8274D;  v116 = 0x19FF1D31;  v117 = 0xCC9235FE;  sub_100020F0(&v105, (int)&v157, v106 - 4, v34);  LOBYTE(v164) = 10;  v35 = string_decryption(&v101, (int)"Ôk-èþ'\nÑû/.@]e*FæÛ");// .doc  v36 = (const unsigned __int16 *)v35;  LOBYTE(v164) = 11;  if ( *((_DWORD *)v35 + 5) >= 8u )  v36 = *(const unsigned __int16 **)v35;  if ( *v36 )  v37 = wcslen(v36);  else  v37 = 0;  v38 = sub_100023E0((int)&v157, v37, v158, v36, v37) == 0;// what kind of file ending do we have?  if ( v103 >= 8 )  j__free(v101);  if ( v38 )  {  v82 = 0;  v81 = 0;  // inlined MD5_Init  v77 = 0x67452301;  v78 = 0xEFCDAB89;  v79 = 0x98BADCFE;  v80 = 0x10325476;  MD5_Update(find_file_data.cFileName, (MD5_CTX *)&v77, 2 * v106);  MD5_Final((int)&md5_result, (int)&v77);  md5_result_ = (BYTE *)&md5_result;  v40 = 12;  computed_hash_ = (BYTE *)&computed_hash;  while ( *(_DWORD *)md5_result_ == *(_DWORD *)computed_hash_ )  {  md5_result_ += 4;  computed_hash_ += 4;  v42 = v40 < 4;  v40 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  goto LABEL_87;  }  }  LOBYTE(v29) = v112;LABEL_87:  v43 = &md5_result;  v44 = 12;  v45 = (int *)&new_hash;  while ( *(_DWORD *)v43 == *v45 )  {  v43 += 4;  ++v45;  v42 = v44 < 4;  v44 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v46 = &md5_result;  v47 = 12;  v48 = &new_hash2;  while ( *(_DWORD *)v46 == *v48 )  {  v46 += 4;  ++v48;  v42 = v47 < 4;  v47 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v49 = &md5_result;  v50 = 12;  v51 = (int *)&new_hash3;  while ( *(_DWORD *)v49 == *v51 )  {  v49 += 4;  ++v51;  v42 = v50 < 4;  v50 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v52 = &md5_result;  v53 = 12;  v54 = &new_hash4;  while ( *(_DWORD *)v52 == *v54 )  {  v52 += 4;  ++v54;  v42 = v53 < 4;  v53 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v55 = &md5_result;  v56 = 12;  v57 = &new_hash5;  while ( *(_DWORD *)v55 == *v57 )  {  v55 += 4;  ++v57;  v42 = v56 < 4;  v56 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v58 = &md5_result;  v59 = 12;  v60 = (int *)&new_hash6;  while ( *(_DWORD *)v58 == *v60 )  {  v58 += 4;  ++v60;  v42 = v59 < 4;  v59 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v61 = &md5_result;  v62 = 12;  v63 = (int *)&new_hash7;  while ( *(_DWORD *)v61 == *v63 )  {  v61 += 4;  ++v63;  v42 = v62 < 4;  v62 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v64 = &md5_result;  v65 = 12;  v66 = (int *)&new_hash8;  while ( *(_DWORD *)v64 == *v66 )  {  v64 += 4;  ++v66;  v42 = v65 < 4;  v65 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v67 = &md5_result;  v68 = 12;  v69 = (int *)&new_hash9;  while ( *(_DWORD *)v67 == *v69 )  {  v67 += 4;  ++v69;  v42 = v68 < 4;  v68 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  }  else  {  LOBYTE(v29) = v112;  }  LOBYTE(v164) = 9;  if ( v159 >= 8 )  j__free(v157);  v14 = directoy_path_;  }  v70 = (_BYTE)found_haekelmuster_dir__ == 0;  LOBYTE(found_haekelmuster_dir__) = v162;  if ( !v70 || v162 )  {  v71 = string_decryption(&v157, (int)&dword_10017780);// Gefunden: %s %s  v72 = (const unsigned __int16 *)v71;  LOBYTE(v164) = 0xC;  if ( *((_DWORD *)v71 + 5) >= 8u )  v72 = *(const unsigned __int16 **)v71;  v156 = 7;  v155 = 0;  LOWORD(gefunden_format) = 0;  if ( *v72 )  {  v73 = wcslen(v72);  v14 = directoy_path_;  }  else  {  v73 = 0;  }  memcpy((int)&gefunden_format, (void *)v72, v73);  size_of_name = unknown_libname_1((int)v14);  output_to_file((int)&gefunden_format, size_of_name, (int)find_file_data.cFileName);  if ( v156 >= 8 )  j__free(gefunden_format);  v156 = 7;  v155 = 0;  LOWORD(gefunden_format) = 0;  if ( v159 >= 8 )  j__free(v157);  }  v164 = -1;  if ( v107 >= 8 )  j__free(v105);  v107 = 7;  v106 = 0;  LOWORD(v105) = 0;  }  }  while ( ((int (__stdcall *)(int, WIN32_FIND_DATA *))FindNextFileW)(v16, &find_file_data) );  FindClose_(v16);  a3 = v161;  }  result = a3;  }  else  {  sub_10004267((int)L"recursiveFindFile dynresolve failed\r\n", v75);  result = 0;  }  return result;}_________________________________________________________________________________________________________________________________________________________________________Hier sind so gut wie alle Imports versteckt, Strings sind mit der selben Encryption versehen worden, wie bereits der RC4 Key. Nachdem man allerdings alle Strings mitgeloggt hat, wird schnell klar, was hier passiert. Die Funktion sub_10001200 dient quasi als GetProcAddress Ersatz, Imports werden manuell resolved.Da ich keine Lust habe, auf alles genaustens einzugehen, gibt es hier ne kleine Zusammenfassung:Die Partition, die der User als Parameter übergeben hat wird mithilfe von FindFirstFileW/FindNextFileW auf einen Ordner namens "Haekelmuster" oder "Häkelmuster" durchsucht. Falls dieser gefunden wurde, ruft die Directorysearch Funktion sich selbst auf (rekursiv halt) und durchsucht den Inhalt des gefundenen Ordners. Zusätzlich wird das momentan durchsuchte Verzeichnis auf mehrere Dateien überprüft: "Büschelmaschen.jpg", "Kettmaschen.jpg" und "Topflappen.jpg". Falls eine der Dateien gefunden wurde, wird in die zuvor angegebene Outputfile Folgendes geschrieben: "Gefunden: directory+filename". Das Output wird allerdings vorher mit RC4 verschlüsselt. Dafür ist die Funktion "output_to_file" (sub_100012A0) zuständig (hier findet man den zweiten Teil der RC4 Encryption).Um das Ganze abzuschließen, komme ich nun zu der letzten Frage: "Fortgeschritten: Was wird mit der Hashfunktion verschleiert?":Auffällig ist dieses Stückchen Code:_______________________________________________________________________________________________________computed_hash = 0x78440D12;  v135 = 0x30345F1E;  v136 = 0x6887213C;  v137 = 0xE12465C1;  new_hash = 0xC6DD61BE;  v143 = 0x741077EA;  v144 = 0x80F53A6B;  v145 = 0x47C05A2F;  new_hash2 = 0x78A75BF0;  v131 = 0xB14F95CD;  v132 = 0x17D17AC2;  v133 = 0x75B06B0E;  new_hash3 = 0xFE64365C;  v119 = 0x576ACC51;  v120 = 0x70A22858;  v121 = 0x43D40F37;  new_hash4 = 0x7F9FB97E;  v127 = 0x85707DDA;  v128 = 0xA2BDE1A1;  v129 = 0x11A34AB0;  new_hash5 = 0x5EC20AEA;  v139 = 0xDF531C51;  v140 = 0x1BD49218;  v141 = 0x8202B9C8;  new_hash6 = 0x87FDCF71;  v147 = 0x4B82FD9C;  v148 = 0x137A8BAA;  v149 = 0xD55096A1;  new_hash7 = 0xDA70241D;  v123 = 0x90FC9224;  v124 = 0xD3B15F;  v125 = 0xDE4A49BA;  new_hash8 = 0xA81C251F;  v151 = 0x399C436A;  v152 = 0xF85D4AA0;  v153 = 0xE2BB7CA1;  new_hash9 = 0x8045AAC5;  v115 = 0x6BF8274D;  v116 = 0x19FF1D31;  v117 = 0xCC9235FE;  sub_100020F0(&v105, (int)&v157, v106 - 4, v34);  LOBYTE(v164) = 10;  v35 = string_decryption(&v101, (int)"Ôk-èþ'\nÑû/.@]e*FæÛ");// .doc  v36 = (const unsigned __int16 *)v35;  LOBYTE(v164) = 11;  if ( *((_DWORD *)v35 + 5) >= 8u )  v36 = *(const unsigned __int16 **)v35;  if ( *v36 )  v37 = wcslen(v36);  else  v37 = 0;  v38 = sub_100023E0((int)&v157, v37, v158, v36, v37) == 0;// what kind of file ending do we have?  if ( v103 >= 8 )  j__free(v101);  if ( v38 )  {  v82 = 0;  v81 = 0;  // inlined MD5_Init  v77 = 0x67452301;  v78 = 0xEFCDAB89;  v79 = 0x98BADCFE;  v80 = 0x10325476;  MD5_Update(find_file_data.cFileName, (MD5_CTX *)&v77, 2 * v106);  MD5_Final((int)&md5_result, (int)&v77);  md5_result_ = (BYTE *)&md5_result;  v40 = 12;  computed_hash_ = (BYTE *)&computed_hash;  while ( *(_DWORD *)md5_result_ == *(_DWORD *)computed_hash_ )  {  md5_result_ += 4;  computed_hash_ += 4;  v42 = v40 < 4;  v40 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  goto LABEL_87;  }  }  LOBYTE(v29) = v112;LABEL_87:  v43 = &md5_result;  v44 = 12;  v45 = (int *)&new_hash;  while ( *(_DWORD *)v43 == *v45 )  {  v43 += 4;  ++v45;  v42 = v44 < 4;  v44 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v46 = &md5_result;  v47 = 12;  v48 = &new_hash2;  while ( *(_DWORD *)v46 == *v48 )  {  v46 += 4;  ++v48;  v42 = v47 < 4;  v47 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v49 = &md5_result;  v50 = 12;  v51 = (int *)&new_hash3;  while ( *(_DWORD *)v49 == *v51 )  {  v49 += 4;  ++v51;  v42 = v50 < 4;  v50 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v52 = &md5_result;  v53 = 12;  v54 = &new_hash4;  while ( *(_DWORD *)v52 == *v54 )  {  v52 += 4;  ++v54;  v42 = v53 < 4;  v53 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v55 = &md5_result;  v56 = 12;  v57 = &new_hash5;  while ( *(_DWORD *)v55 == *v57 )  {  v55 += 4;  ++v57;  v42 = v56 < 4;  v56 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v58 = &md5_result;  v59 = 12;  v60 = (int *)&new_hash6;  while ( *(_DWORD *)v58 == *v60 )  {  v58 += 4;  ++v60;  v42 = v59 < 4;  v59 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v61 = &md5_result;  v62 = 12;  v63 = (int *)&new_hash7;  while ( *(_DWORD *)v61 == *v63 )  {  v61 += 4;  ++v63;  v42 = v62 < 4;  v62 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v64 = &md5_result;  v65 = 12;  v66 = (int *)&new_hash8;  while ( *(_DWORD *)v64 == *v66 )  {  v64 += 4;  ++v66;  v42 = v65 < 4;  v65 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  v67 = &md5_result;  v68 = 12;  v69 = (int *)&new_hash9;  while ( *(_DWORD *)v67 == *v69 )  {  v67 += 4;  ++v69;  v42 = v68 < 4;  v68 -= 4;  if ( v42 )  {  LOBYTE(v29) = 1;  break;  }  }  }  else  {  LOBYTE(v29) = v112;  }  LOBYTE(v164) = 9;  if ( v159 >= 8 )  j__free(v157);  v14 = directoy_path_;  }  _______________________________________________________________________________________________________________________________Auch hier lässt sich anhand gewisser Konstanten (siehe inlined MD5_Init) erkennen, dass es sich um MD5 handeln muss. Es wurden also Hashes precomputed und auf dem Stack gespeichert (vier DWORDs ergeben einen Hash (128bit)). Es handelt sich um 11 Hashes. Bevor diese allerdings verwendet werden, wird in Zeile 415 überprüft, ob es sich bei der gefundenen File um eine .doc File handelt. Falls ja, wird der MD5-Hash ihres Namens berechnet und anschließend gegen die 11 angegeben Hashes gecheckt.Auf diese Art und Weise konnte der Name der gesuchten Files erfolgreich versteckt/verschleiert werden. Ich habe bei ein paar Hashes probiert, an den ursprünglichen Filename mithilfe von riesigen Lookuptables zu gelangen, leider ohne Erfolg.Ich habe ein kleines Tool geschrieben, welches die Outputfiles decrypted und in eine Console printed:______________________________________________________________________________________________________________int main(void){   FILE *read_file = fopen("encrypted_file.txt", "rb");   if (!read_file)     return -1;   fseek(read_file, 0, SEEK_END);   size_t size = ftell(read_file);   fseek(read_file, 0, SEEK_SET);   printf("file size: %i\n", size);   uint8_t *data = (BYTE*)malloc(size);   const wchar_t *key = L"Amigurumi";   fread(data, size, 1, read_file);   rc4_init((uint8_t*)(key), wcslen(key) * 2);   for (int i = 0; i < size; i++)     data[i] ^= rc4_output();//printf("%02X", test_vectors[x][1][y] ^ rc4_output());   wprintf(L"%s\n", data);   getchar();   free(data);   fclose(read_file);   return 0;}___________________________________________________________________________________________________________Zusammenfassung: Die Komponente durchsucht eine angegebene Partition auf bestimmte Ordner und Files. Falls eine File gefunden wurde, wird ihr Name und ihr Pfad in der Outputfile gespeichert.