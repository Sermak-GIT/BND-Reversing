Bei Level 2 handelt es sich um eine native 32-bit Konsolenanwendung, vermutlich in C/C++ geschrieben.Beim Betrachten der main Funktion (sub_00401A00 / int __cdecl main(size_t num_of_args, char **args)) wird schnell deutlich, dass die Binary zusätzliche Commandlineargumente benötigt. Checks wie diese lassen uns schnell erkennen, wie viele genau:________________________________________if ( num_of_args == 4 )  // 3 args...________________________________________Auffällig ist als nächstes der folgende Call:_____________________________________________________________________________if ( sub_00401960(args[1], some_byte_array) ) //sizeof(some_byte_array) == 16______________________________________________________________________________Schnell wird klar, dass diese Funktion sscanf verwendet, um das Userinput in ein Bytearray zu formatieren. Anschließend wird dieses Bytearray noch folgenderweise gexored:______________________________________________________________________________  v4 = 0;  do  {  some_byte_array[v4] ^= (unsigned __int8)(2 * v4) ^ 0x55;  ++v4;  }  while ( v4 < 16 );____________________________________________________________________________Nun wird die File mit dem Namen des zweiten Commandlinearguments mit Lesezugriff ("rb") geöffnet (fopen) und eine neue File mit dem Namen des dritten Commandlinearguments mit Schreibezugriff ("wb") geöffnet/erstellt. Falls beide Operationen erfolgreich waren, wird die Größe der zu lesenden File (ab jetzt "in_file" genannt) ermittelt (fseek & ftell). Die Filesize wird auf 16 Bytes aligned. In die zu schreibende File (ab jetzt "out_file" genannt) wird folgender String geschrieben: "Total toll verschluesselt!" (.rdata:0041753C). Direkt danach wird die ermittelte Size der in_file geschrieben. Das zuvor ermittelte und generierte Bytearray (some_byte_array) wird ebenfalls in die out_file geschrieben. Nun wird Speicher der Größe der in_file allocated (malloc) und mit '0' gecleared (memset). Anschließend wird der Inhalt der in_file in diesen Speicher gelesen (fread). Erneut wird Memory mit der Größe der in_file allocated.Im Folgenden bleiben zwei interessante Funktionen offen: sub_00401000 und sub_00401780. Schnell wird klar, dass es sich hier um aes_expand_key und aes_encrypt (mehr oder weniger gängige Namen) handelt (man erkennt große Tables voller Konstanten, die typisch für AES sind). Es handelt sich um eine AES 128 bit CBC Encryption. Das verschlüsselte Bytearray (some_byte_array) wird anschließend mit dem selben Algorithmus mit dem es zuvor verschlüsselt wurde wieder entschlüsselt. Es dient nun als Key der AES Encryption.Der IV wird folgendermaßen generiert:________________________________________  v11 = 0;  do  {  IV[v11] = v11 ^ v10;  ++v11;  }  while ( v11 < 16 );_________________________________________Dass es sich hierbei um den IV handelt erkennt man, wenn man die Verwendung innerhalb der aes_encrypt Funktion betrachtet. An diese wird der IV als letzter Parameter übergeben.Was wird denn nun encrypted? Der zuvor gelesene Inhalt der in_file wird mithilfe der AES Encryption verschlüsselt und in dem als zweites allokierten Speicher hinterlegt. Dieser wird anschließend in die out_file geschrieben.Wir haben alle nötigen Informationen:Das Format der out_file: ["Total toll verschluesselt!" - file_size - encrypted_aes_key - encrypted_data].Ich habe mir ein kleines Tool geschrieben, welches die Files wieder entschlüsselt:_____________________________________________________________________________________________________void DecryptKey(char *in){   int v4 = 0;   do   {     in[v4] ^= (2 * v4) ^ 0x55;     ++v4;   } while (v4 < 16);}int main(void){   FILE *encrypted_file = fopen("Urlaubsphoto2.png.crypt", "rb");   uint8_t IV[16];   uint8_t aes_key[16];   size_t offset = strlen(some_message);   fseek(encrypted_file, offset, SEEK_SET);   size_t size = -1;   fread(&size, 4, 1, encrypted_file);   printf("File size: %i\n", size);   for (int i = 0; i < 16; i++)     IV[i] = i ^ size;   fread(aes_key, 16, 1, encrypted_file);   DecryptKey((char*)aes_key);   for (int i = 0; i < 16; i++)     printf("%x", aes_key[i]);   if (size & 0xF)     size = size - (size & 0xF) + 16;   uint8_t *in_data = malloc(size);   memset(in_data, 0, size);   fread(in_data, size, 1, encrypted_file);   uint8_t *out_data = malloc(size);   memset(out_data, 0, size);   AES128_CBC_decrypt_buffer(out_data, in_data, size, aes_key, IV);   fclose(encrypted_file);   FILE *decrypted_file = fopen("image.png", "wb");   fwrite(out_data, size, 1, decrypted_file);   fclose(decrypted_file);   free(in_data);   free(out_data);   return 0;}___________________________________________________________________________________________________________________Die Lösung ist ein Bild des Taj Mahals: https://i.imgur.com/fSyZNDq.pngZusammenfassung: Level 2 ist eine Art "Cryptotrojaner", der eine gegebene File mit der AES Encryption verschlüsselt. Alle Informationen, die zur Entschlüsselung benötigt werden, findet man in der verschlüsselten File.